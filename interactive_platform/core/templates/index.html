{% load static %}
<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trilha de Aprendizagem Python</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêç</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700&family=Roboto:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="{% static 'css/map.css' %}">
</head>

<body>

    <!-- Cont√™iner para a anima√ß√£o de fundo din√¢mica -->
    <div id="background-animation"></div>

    <!-- SVG para definir o padr√£o de grama do fundo -->
    <svg width="0" height="0" style="position:absolute; z-index: -1;">
        <defs>
            <pattern id="grass-pattern" patternUnits="userSpaceOnUse" width="100" height="100">
                <!-- Fundo mais claro para o padr√£o -->
                <rect width="100" height="100" fill="#2c3e50" />
                <!-- L√¢minas de grama com cores e posi√ß√µes variadas -->
                <path d="M 0 100 C 10 80, 15 40, 20 0" stroke="#2a9d8f" stroke-width="1.5" fill="none" opacity="0.3" />
                <path d="M 25 100 C 35 80, 40 40, 45 0" stroke="#34495e" stroke-width="2" fill="none" opacity="0.4" />
                <path d="M 50 100 C 60 80, 65 40, 70 0" stroke="#2a9d8f" stroke-width="1" fill="none" opacity="0.2" />
                <path d="M 75 100 C 85 80, 90 40, 95 0" stroke="#34495e" stroke-width="1.5" fill="none" opacity="0.3" />
            </pattern>
        </defs>
    </svg>

    <header class="map-header">
        <h1>üêç Trilha de Aprendizagem Python üêç</h1>
        
        <div class="gamification-stats">
            <div class="player-info">
                <span id="player-avatar" class="player-avatar"></span>
                <span id="player-name" class="player-name"></span>
            </div>
            <span id="player-score">üèÜ Pontos: 0</span>
            <span id="course-timer" class="player-score" style="display: none;">‚è∞ Tempo: 00:00</span>
            <button id="reset-progress-btn" title="Resetar todo o progresso e pontos">üîÑ Resetar</button>
        </div>
    </header>

    <main class="map-container">
        <svg class="map-path-svg" viewBox="0 0 800 1600" preserveAspectRatio="none">
            <defs>
                <linearGradient id="snakeGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#FFD43B;" />
                    <stop offset="50%" style="stop-color:#3776AB;" />
                    <stop offset="100%" style="stop-color:#FFD43B;" />
                    <!-- Anima o gradiente para criar sensa√ß√£o de fluxo -->
                    <animateTransform attributeName="gradientTransform" type="translate" from="-1 0" to="1 0" dur="8s" repeatCount="indefinite" />
                </linearGradient>
                <!-- Filtro de brilho suave para a trilha -->
                <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" />
                    <feMerge>
                        <feMergeNode in="blur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>
            </defs>
            <!-- Caminho de contorno (atr√°s) -->
            <path class="snake-path-outline" d="M 400 50 
                C 400 100, 100 150, 100 200
                S 100 250, 400 300
                S 700 350, 700 400
                S 700 450, 400 500
                S 100 550, 100 600
                S 100 650, 400 700
                S 700 750, 700 800
                S 700 850, 400 900
                S 100 950, 100 1000
                S 100 1050, 400 1100
                S 700 1150, 700 1200
                S 700 1250, 400 1300
                S 100 1350, 100 1400
                S 100 1450, 400 1500
                
                " />
            <!-- Caminho de preenchimento (frente) -->
            <path id="snakePath" class="snake-path-fill" d="M 400 50 
                C 400 100, 100 150, 100 200
                S 100 250, 400 300
                S 700 350, 700 400
                S 700 450, 400 500
                S 100 550, 100 600
                S 100 650, 400 700
                S 700 750, 700 800
                S 700 850, 400 900
                S 100 950, 100 1000
                S 100 1050, 400 1100
                S 700 1150, 700 1200
                S 700 1250, 400 1300 
                S 100 1350, 100 1400
                S 100 1450, 400 1500
                " />
            <!-- Ponto luminoso viajando pela trilha -->
            <circle class="runner-dot" r="6" fill="#ffffff">
                <animateMotion dur="10s" repeatCount="indefinite" rotate="auto">
                    <mpath href="#snakePath" />
                </animateMotion>
            </circle>
        </svg>

        <div class="map-stops">
            <!-- As paradas do mapa agora est√£o diretamente no HTML -->
            <div class="map-stop" data-step="1" style="left: 50%; top: 50px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 1</span><span class="stop-title">ü§î Quem √© voc√™?</span></div></div>
            <div class="map-stop" data-step="2" style="left: 12.5%; top: 200px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 2</span><span class="stop-title">üéØ Situa√ß√£o-Problema</span></div></div>
            <div class="map-stop" data-step="3" style="left: 50%; top: 300px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 3</span><span class="stop-title">‚öôÔ∏è O que √© Backend?</span></div></div>
            <div class="map-stop" data-step="4" style="left: 87.5%; top: 400px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 4</span><span class="stop-title">üìö Linguagens</span></div></div>
            <div class="map-stop" data-step="5" style="left: 50%; top: 500px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 5</span><span class="stop-title">üêç Por que Python?</span></div></div>
            <div class="map-stop" data-step="6" style="left: 12.5%; top: 600px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 6</span><span class="stop-title">üì¶ Vari√°veis</span></div></div>
            <div class="map-stop" data-step="7" style="left: 50%; top: 700px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 7</span><span class="stop-title">‚ñ∂Ô∏è Primeiros Passos</span></div></div>
            <div class="map-stop" data-step="8" style="left: 87.5%; top: 800px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 8</span><span class="stop-title">üö¶ Controlando o Fluxo</span></div></div>
            <div class="map-stop" data-step="9" style="left: 50%; top: 900px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 9</span><span class="stop-title">üß∞ Estruturas de Dados</span></div></div>
            <div class="map-stop" data-step="10" style="left: 12.5%; top: 1000px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 10</span><span class="stop-title">üß© Construtor de C√≥digo</span></div></div>
            <div class="map-stop" data-step="11" style="left: 50%; top: 1100px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 11</span><span class="stop-title">üìù Avalia√ß√£o</span></div></div>
            <div class="map-stop" data-step="12" style="left: 87.5%; top: 1200px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 12</span><span class="stop-title">üèÜ Desafio Final</span></div></div>
            <div class="map-stop" data-step="13" style="left: 50%; top: 1300px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 13</span><span class="stop-title">üèÅ Conclus√£o</span></div></div>
            <div class="map-stop" data-step="14" style="left: 12.5%; top: 1400px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 14</span><span class="stop-title">üìú Certificado</span></div></div>
            <div class="map-stop" data-step="15" style="left: 50%; top: 1500px;"><div class="stop-icon"></div><div class="stop-label"><span class="stop-step">Etapa 15</span><span class="stop-title">üéÆ Jogos (Extra)</span></div></div>
        </div>

        <!-- Modal para exibir a aula -->
        <div class="modal-overlay" id="lesson-modal">
            <div class="modal-content">
                <button class="modal-close-btn" id="modal-close-btn">&times;</button>
                <div class="iframe-container">
                    <iframe id="lesson-iframe" src="" frameborder="0"></iframe>
                </div>
            </div>
        </div>

        <!-- Notifica√ß√£o de Recompensa (Toast) -->
        <div id="toast-notification" class="toast"></div>

        <!-- Anima√ß√£o de Pontos Ganhos -->
        <div id="points-animation" class="points-animation">+10 Pontos!</div>

    </main>

    <!-- Se√ß√£o Hall da Fama -->
    <section class="hall-of-fame">
        <h2>üèÜ Hall da Fama üèÜ</h2>
        <p>Os melhores aventureiros da Trilha Python!</p>
        <ul class="hall-of-fame-list" id="hall-of-fame-list">
            <!-- O ranking ser√° preenchido pelo JavaScript -->
            <li>Carregando ranking...</li>
            <style>
                .player-time {
                    color: var(--muted);
                    font-size: 0.9em;
                }
            </style>
        </ul>
    </section>


    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <script>
        // --- Script para Anima√ß√£o de Fundo Din√¢mica ---
        document.addEventListener('DOMContentLoaded', () => {
            const backgroundContainer = document.getElementById('background-animation');
            if (!backgroundContainer) return;

            const symbols = ['def', 'class', 'import', 'print()', 'for in', 'if else', '()', '{}', '[]', '=>', 'üêç', '<>', '"""', '#', 'lambda', 'True', 'False', '__init__'];
            const colors = ['var(--python-blue)', 'var(--python-yellow)', 'var(--python-green)'];
            // Menos elementos no mobile para melhor performance
            const numberOfSymbols = window.matchMedia('(max-width: 768px)').matches ? 24 : 50;

            for (let i = 0; i < numberOfSymbols; i++) {
                const symbolEl = document.createElement('div');
                symbolEl.classList.add('floating-symbol');
                symbolEl.textContent = symbols[Math.floor(Math.random() * symbols.length)];

                // Posi√ß√£o e tamanho aleat√≥rios
                symbolEl.style.left = `${Math.random() * 100}vw`;
                symbolEl.style.top = `${Math.random() * 100}vh`;
                symbolEl.style.fontSize = `${Math.random() * 1.5 + 0.5}rem`; // Tamanho entre 0.5rem e 2.0rem
                symbolEl.style.color = colors[Math.floor(Math.random() * colors.length)];

                // Dura√ß√£o e atraso da anima√ß√£o aleat√≥rios
                const duration = Math.random() * 20 + 15; // Dura√ß√£o entre 15s e 35s
                const delay = Math.random() * -35; // Atraso negativo para come√ßar em pontos diferentes
                symbolEl.style.animation = `floatAndDrift ${duration}s ${delay}s linear infinite`;

                backgroundContainer.appendChild(symbolEl);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            const stopsContainer = document.querySelector('.map-stops');
            const scoreDisplay = document.getElementById('player-score');
            const avatarDisplay = document.getElementById('player-avatar');
            const playerNameDisplay = document.getElementById('player-name');
            const hallOfFameList = document.getElementById('hall-of-fame-list');
            const toast = document.getElementById('toast-notification');

            const modal = document.getElementById('lesson-modal');
            const iframe = document.getElementById('lesson-iframe');
            const closeModalBtn = document.getElementById('modal-close-btn');

            const stopsData = [
                { step: 1, title: 'ü§î Quem √© voc√™?', icon: '‚ùì' },
                { step: 2, title: 'üéØ Situa√ß√£o-Problema', icon: 'üéØ' },
                { step: 3, title: '‚öôÔ∏è O que √© Backend?', icon: '‚öôÔ∏è' },
                { step: 4, title: 'üìö Linguagens', icon: 'üìö' },
                { step: 5, title: 'üêç Por que Python?', icon: 'üêç' },
                { step: 6, title: 'üì¶ Vari√°veis', icon: 'üì¶' },
                { step: 7, title: '‚ñ∂Ô∏è Primeiros Passos', icon: '‚ñ∂Ô∏è' },
                { step: 8, 'title': 'üö¶ Controlando o Fluxo', icon: 'üö¶' },
                { step: 9, 'title': 'üß∞ Estruturas de Dados', icon: 'üß∞' },
                { step: 10, 'title': 'üß© Construtor de C√≥digo', icon: 'üß©' },
                { step: 11, 'title': 'üìù Avalia√ß√£o', icon: 'üìù' },
                { step: 12, 'title': 'üèÜ Desafio Final', icon: 'üèÜ' },
                { step: 13, 'title': 'üèÅ Conclus√£o', icon: 'üèÅ' },
                { step: 14, 'title': 'üìú Certificado', icon: 'üìú' },
                { step: 15, 'title': 'üéÆ Jogos (Extra)', icon: 'üéÆ' }
            ];

            function updatePlayerInfo() {
                // Atualiza a pontua√ß√£o
                const currentScore = parseInt(localStorage.getItem('playerScore') || '0');
                scoreDisplay.textContent = `üèÜ Pontos: ${currentScore}`;

                // Atualiza o avatar
                const studentDataRaw = localStorage.getItem('studentData');
                if (studentDataRaw) {
                    const studentData = JSON.parse(studentDataRaw);
                    const currentAvatar = avatarDisplay.textContent;
                    const newAvatar = studentData.avatar || 'üêç';

                    // Anima o avatar apenas se ele for novo ou diferente
                    if (newAvatar && currentAvatar !== newAvatar) {
                        avatarDisplay.textContent = newAvatar;
                        avatarDisplay.classList.add('animate-in');
                        // Remove a classe ap√≥s a anima√ß√£o para n√£o repetir
                        avatarDisplay.addEventListener('animationend', () => {
                            avatarDisplay.classList.remove('animate-in');
                        }, { once: true });
                    }

                    playerNameDisplay.textContent = studentData.name || '';
                }
            }

            function renderMap() {
                // Pega o progresso salvo. O padr√£o √© 1 (primeira etapa desbloqueada).
                const unlockedUntil = parseInt(localStorage.getItem('unlockedStep') || '1');
                const allStops = document.querySelectorAll('.map-stop');

                allStops.forEach((stopElement, index) => {
                    const step = parseInt(stopElement.dataset.step);
                    const data = stopsData.find(d => d.step === step);
                    if (!data) return;

                    const isLocked = data.step > unlockedUntil;
                    const stopIcon = stopElement.querySelector('.stop-icon');

                    // Limpa classes antigas e adiciona as novas
                    stopElement.classList.remove('locked', 'next-to-unlock');

                    if (isLocked) {
                        stopElement.classList.add('locked');
                    } else if (data.step === unlockedUntil) {
                        stopElement.classList.add('next-to-unlock');
                    }

                    stopElement.style.animationDelay = `${index * 0.1}s`;

                    // Define o √≠cone correto
                    if (stopIcon) {
                        stopIcon.textContent = isLocked ? 'üîí' : (data.step < unlockedUntil ? '‚úÖ' : data.icon);
                    }

                    if (!isLocked) {
                        stopElement.addEventListener('click', () => {
                            openModal(data.step, data.title);
                        });
                    } else {
                        stopElement.replaceWith(stopElement.cloneNode(true)); // Remove event listeners antigos
                    }
                });
            }

            function openModal(step, title) {
                // Gera a URL base para a view 'aula' usando a tag de template do Django.
                const baseUrl = "{% url 'aula' %}";
                // Carrega a p√°gina da aula no iframe, j√° na √¢ncora correta
                iframe.src = `${baseUrl}#step-${step}`;

                // Adiciona um listener para o evento 'load' do iframe
                iframe.addEventListener('load', function scrollToTop() {
                    // Rola o conte√∫do do iframe para o topo
                    if (iframe.contentWindow) iframe.contentWindow.scrollTo(0, 0);
                });

                modal.style.display = 'flex';
                document.body.style.overflow = 'hidden'; // Impede o scroll do mapa
            }

            function closeModal() {
                modal.style.display = 'none';
                iframe.src = ''; // Limpa o iframe para parar a execu√ß√£o
                document.body.style.overflow = 'auto';

                // Sincroniza com o backend e depois recarrega a p√°gina para garantir que o progresso seja exibido.
                updatePlayerInBackend();
                window.location.reload();
            }

            closeModalBtn.addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            });

            // Ouve mensagens do iframe (da p√°gina da aula)
            window.addEventListener('message', (event) => {
                // Verificamos a origem por seguran√ßa, mas para arquivos locais pode ser 'null'
                const { type, unlockedStep, points = 10 } = event.data;

                if (type === 'UPDATE_PROGRESS' && unlockedStep) {
                    const completedStep = unlockedStep - 1;

                    // Adiciona pontos e dispara anima√ß√µes
                    triggerPointsAnimation(points);
                    addPoints(points);
                    triggerConfetti();

                    // Atualiza o progresso localmente
                    localStorage.setItem('unlockedStep', unlockedStep);

                    // Redesenha o mapa para refletir o novo estado
                    renderMap();

                    // Mostra a notifica√ß√£o de recompensa
                    const stepTitle = stopsData.find(s => s.step === completedStep)?.title || `Etapa ${completedStep}`;
                    showReward(`Parab√©ns! Voc√™ concluiu: ${stepTitle}`);
                }

            });

            // --- NOVO: Fun√ß√£o para formatar o tempo para o Hall da Fama ---
            function formatTime(seconds) {
                if (!seconds || seconds <= 0) {
                    return '';
                }
                const hrs = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;
                // Exibe HH:MM:SS quando houver horas; caso contr√°rio, MM:SS
                return hrs > 0
                    ? `${String(hrs).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`
                    : `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }

            // --- NOVO: Fun√ß√£o para buscar e renderizar o Hall da Fama ---
            async function updateAndRenderHallOfFame() {
                hallOfFameList.innerHTML = '<li>Carregando ranking...</li>';
                try {
                    const response = await fetch("{% url 'get_hall_of_fame' %}");
                    if (!response.ok) {
                        throw new Error(`Erro na API: ${response.statusText}`);
                    }
                    const hallOfFame = await response.json();

                    hallOfFameList.innerHTML = ''; // Limpa a lista
                    if (hallOfFame.length === 0) {
                        hallOfFameList.innerHTML = '<li>O ranking ainda est√° vazio. Seja o primeiro a pontuar!</li>';
                        return;
                    }

                    hallOfFame.forEach((player, index) => {
                        const rank = index + 1;
                        const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
                        const timeString = formatTime(player.completion_time_seconds);
                        const timeHtml = timeString ? `<span class="player-time">‚Ä¢ Tempo: ${timeString}</span>` : '';

                        const li = document.createElement('li');
                        li.className = `rank-${rank}`;
                        li.innerHTML = `<div class="player-rank-info"><span class="rank">${medal}</span><span class="player-avatar">${player.avatar}</span> <span class="player-name">${player.name}</span></div><span class="player-score-hof">${player.score} Pontos ${timeHtml}</span>`;
                        hallOfFameList.appendChild(li);
                    });
                } catch (error) {
                    console.error("Falha ao buscar Hall da Fama:", error);
                    hallOfFameList.innerHTML = '<li>Erro ao carregar o ranking. Tente novamente mais tarde.</li>';
                }
            }

            // --- NOVO: Fun√ß√£o para enviar dados ao backend ---
            async function updatePlayerInBackend() {
                const studentDataRaw = localStorage.getItem('studentData');
                const score = parseInt(localStorage.getItem('playerScore') || '0');
                const unlockedStep = parseInt(localStorage.getItem('unlockedStep') || '1');
                const completionTime = localStorage.getItem('completionTimeSeconds');
                const researchNotes = localStorage.getItem('pythonResearchNotes'); // Pega as anota√ß√µes

                if (!studentDataRaw) return; // N√£o faz nada se n√£o houver dados do aluno

                const studentData = JSON.parse(studentDataRaw);
                const payload = {
                    name: studentData.name,
                    avatar: studentData.avatar,
                    score: score,
                    unlocked_step: unlockedStep,
                    completion_time_seconds: completionTime ? parseInt(completionTime) : null,
                    research_notes: researchNotes // Adiciona ao payload
                };

                try {
                    await fetch("{% url 'update_player' %}", {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    console.log("Progresso do jogador sincronizado com o backend.");
                } catch (error) {
                    console.error("Falha ao sincronizar dados do jogador:", error);
                    // Opcional: mostrar um aviso ao usu√°rio de que o progresso n√£o foi salvo online.
                }
            }

            function animateScore(startScore, endScore) {
                const duration = 1500; // Dura√ß√£o da anima√ß√£o em milissegundos (1.5s)
                let startTime = null;

                function animation(currentTime) {
                    if (!startTime) startTime = currentTime;
                    const progress = Math.min((currentTime - startTime) / duration, 1);
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3); // Efeito de desacelera√ß√£o

                    const currentDisplayScore = Math.floor(easeOutProgress * (endScore - startScore) + startScore);
                    scoreDisplay.textContent = `üèÜ Pontos: ${currentDisplayScore}`;

                    if (progress < 1) {
                        requestAnimationFrame(animation);
                    }
                }
                requestAnimationFrame(animation);
            }

            function addPoints(amount) {
                const startScore = parseInt(localStorage.getItem('playerScore') || '0');
                const endScore = startScore + amount;
                localStorage.setItem('playerScore', endScore);
                animateScore(startScore, endScore);
            }

            function showReward(message) {
                toast.textContent = message;
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 4000); // A notifica√ß√£o some ap√≥s 4 segundos
            }

            function triggerPointsAnimation(points) {
                const pointsEl = document.getElementById('points-animation');
                pointsEl.textContent = `+${points} Pontos!`;
                pointsEl.classList.add('show');
                setTimeout(() => pointsEl.classList.remove('show'), 2000); // Remove a anima√ß√£o ap√≥s 2s
            }

            function triggerConfetti() {
                confetti({
                    particleCount: 150,
                    spread: 90,
                    origin: { y: 0.6 }
                });
            }

            function scrollToStep(stepNumber) {
                const targetStop = document.querySelector(`.map-stop[data-step="${stepNumber}"]`);
                if (targetStop) {
                    targetStop.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            // Para limpar o progresso e recome√ßar do zero, descomente as linhas abaixo:
            // localStorage.removeItem('unlockedStep');
            // localStorage.removeItem('playerScore');

            const resetBtn = document.getElementById('reset-progress-btn');
            resetBtn.addEventListener('click', () => {
                if (confirm('Voc√™ tem certeza que deseja resetar todo o seu progresso e pontos? Esta a√ß√£o n√£o pode ser desfeita.')) {
                    // Limpa os dados do mapa
                    localStorage.removeItem('unlockedStep');
                    localStorage.removeItem('playerScore');

                    // Limpa dados relacionados √†s aulas
                    localStorage.removeItem('studentData');
                    localStorage.removeItem('pythonResearchNotes');
                    localStorage.removeItem('courseStartTime');
                    localStorage.removeItem('completionTimeSeconds');
                    localStorage.removeItem('timeBonus');
                    localStorage.removeItem('finalQuizCompleted');
                    localStorage.removeItem('satisfactionRating');

                    // Limpa o registro de certificados para for√ßar a recria√ß√£o
                    // (Opcional, mas bom para testes)
                    localStorage.removeItem('certificateRegistry');

                    localStorage.removeItem('theme'); // Limpa tamb√©m o tema

                    // Recarrega a p√°gina para aplicar as mudan√ßas
                    window.location.reload();
                }
            });

            // --- NOVO: Fun√ß√£o para carregar o progresso do backend ---
            async function loadPlayerProgressFromBackend() {
                const studentDataRaw = localStorage.getItem('studentData');
                if (!studentDataRaw) {
                    console.log("Nenhum dado de aluno encontrado localmente. O aluno precisa se registrar primeiro.");
                    return; // Encerra se n√£o houver aluno logado
                }

                const studentData = JSON.parse(studentDataRaw);
                const playerName = studentData.name;

                if (!playerName) return;

                try {
                    const response = await fetch(`/api/player/${encodeURIComponent(playerName)}/`); // Esta URL j√° est√° correta com a nova rota
                    if (!response.ok) {
                        if (response.status === 404) {
                            console.log("Jogador novo. O progresso ser√° criado no backend na primeira sincroniza√ß√£o.");
                        } else {
                            throw new Error(`Erro na API: ${response.statusText}`);
                        }
                        return; // N√£o faz nada se o jogador n√£o for encontrado
                    }

                    const playerData = await response.json();
                    
                    // Atualiza o localStorage com os dados do backend
                    localStorage.setItem('playerScore', playerData.score);
                    localStorage.setItem('unlockedStep', playerData.unlocked_step);

                    console.log("Progresso do jogador carregado do backend:", playerData);

                } catch (error) {
                    console.error("Falha ao carregar progresso do jogador do backend:", error);
                }
            }

            // --- L√≥gica de Inicializa√ß√£o da P√°gina ---
            loadPlayerProgressFromBackend().then(() => {
                updatePlayerInfo(); // Atualiza avatar e pontua√ß√£o
                updateAndRenderHallOfFame(); // Renderiza o Hall da Fama ao carregar
                renderMap(); // Renderiza o mapa
            });

            // --- L√≥gica para salvar o tempo de conclus√£o ---
            // Ouve a mensagem do iframe da aula
            window.addEventListener('message', (event) => {
                const data = event.data;

                // Quando a etapa 15 (desafio final) √© conclu√≠da, o iframe envia uma mensagem
                if (data?.type === 'STEP_UNLOCKED' && data.step === 12) { // Ajustado para a nova numera√ß√£o
                    const startTime = parseInt(localStorage.getItem('courseStartTime') || '0');
                     if (startTime > 0) {
                        const endTime = new Date().getTime();
                        const durationSeconds = Math.floor((endTime - startTime) / 1000);
                        localStorage.setItem('completionTimeSeconds', durationSeconds);
                    }
                } else if (data?.type === 'START_TIMER') { // NOVO: Ouve a mensagem para iniciar o cron√¥metro
                    startCourseTimer();
                } else if (data?.type === 'COURSE_FINISHED') { // NOVO: Ouve a mensagem de finaliza√ß√£o
                    if (courseTimerInterval) clearInterval(courseTimerInterval);
                    setTimeout(closeModal, 1500); // Fecha o modal ap√≥s 1.5s
                }
            });

            // --- NOVO: L√≥gica do Cron√¥metro do Curso ---
            let courseTimerInterval;
            const timerDisplay = document.getElementById('course-timer');

            function startCourseTimer() {
                const startTime = localStorage.getItem('courseStartTime');
                if (!startTime) {
                    timerDisplay.style.display = 'none';
                    return;
                }

                timerDisplay.style.display = 'inline'; // Mostra o cron√¥metro

                // Limpa qualquer intervalo anterior para evitar duplica√ß√£o
                if (courseTimerInterval) {
                    clearInterval(courseTimerInterval);
                }

                courseTimerInterval = setInterval(() => {
                    const now = new Date().getTime();
                    const elapsed = Math.floor((now - startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;

                    timerDisplay.textContent = `‚è∞ Tempo: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }, 1000);
            }

            // Inicia o cron√¥metro ao carregar a p√°gina se o tempo j√° tiver come√ßado
            startCourseTimer();

        });
        
        // --- Matrix Python Rain (canvas) ---
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('background-animation');
            if (!container) return;

            const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            const canvas = document.createElement('canvas');
            canvas.id = 'matrix-canvas';
            // Garante cobertura total do fundo em CSS pixels
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.display = 'block';
            // Limpa qualquer conte√∫do anterior (s√≠mbolos flutuantes) e instala o canvas
            container.innerHTML = '';
            container.appendChild(canvas);
            const ctx = canvas.getContext('2d');

            const styles = getComputedStyle(document.documentElement);
            const PY_BLUE = (styles.getPropertyValue('--python-blue') || '#3776AB').trim();
            const PY_YELLOW = (styles.getPropertyValue('--python-yellow') || '#FFD43B').trim();
            // Maior opacidade para reduzir cauda e polui√ß√£o visual
            const HAZE = 'rgba(13, 43, 78, 0.12)';

            const glyphs = ['def','class','import','print','lambda','for','if','else','try','[]','{}','()','=>',':','#','üêç','True','False','__init__','0','1'];
            const BASE_ALPHA = 0.28; // opacidade base mais discreta
            const HEAD_ALPHA = 0.45; // cabe√ßas levemente mais vis√≠veis

            let fontSize;
            let columns;
            let columnSpacing;
            let drops;
            let rafId = null;
            let tick = 0;
            const advanceEvery = 3; // avan√ßa a queda a cada 3 frames (‚âà 1/3 da velocidade)

            function resizeCanvas() {
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                const cssW = container.clientWidth || container.offsetWidth || window.innerWidth;
                const cssH = container.clientHeight || container.offsetHeight || window.innerHeight;
                canvas.width = Math.floor(cssW * dpr);
                canvas.height = Math.floor(cssH * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                const base = Math.max(16, Math.min(24, Math.floor(cssW / 70)));
                fontSize = base;
                ctx.font = `${fontSize}px Courier New, monospace`;

                // Espa√ßamento das colunas levando em conta o alargamento horizontal
                columnSpacing = Math.max(fontSize, Math.floor(fontSize * 1.25 * 1.05));
                columns = Math.max(1, Math.ceil(cssW / columnSpacing) + 2);
                const maxRows = Math.max(1, Math.ceil(cssH / fontSize) + 2);
                drops = new Array(columns).fill(0).map(() => Math.floor(Math.random() * maxRows));
            }

            function drawFrame(advance) {
                ctx.fillStyle = HAZE;
                const cssW = container.clientWidth || container.offsetWidth || window.innerWidth;
                const cssH = container.clientHeight || container.offsetHeight || window.innerHeight;
                ctx.fillRect(0, 0, cssW, cssH);

                for (let i = 0; i < columns; i++) {
                    const glyph = glyphs[Math.floor(Math.random() * glyphs.length)];
                    const x = Math.floor(i * columnSpacing);
                    const y = drops[i] * fontSize;

                    const isHead = Math.random() < 0.02; // menos destaques para reduzir ru√≠do
                    ctx.globalAlpha = isHead ? HEAD_ALPHA : BASE_ALPHA;
                    ctx.fillStyle = isHead ? PY_YELLOW : PY_BLUE;
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.scale(1.25, 1);
                    ctx.fillText(glyph, 0, 0);
                    ctx.restore();

                    if (advance) {
                        if (y > (container.clientHeight || window.innerHeight) && Math.random() > 0.985) {
                            drops[i] = 0;
                        }
                        drops[i]++;
                    }
                }
                ctx.globalAlpha = 1;
            }

            function loop() {
                tick = (tick + 1) % 60;
                const advance = tick % advanceEvery === 0;
                drawFrame(advance);
                rafId = requestAnimationFrame(loop);
            }

            function start() {
                if (rafId == null) rafId = requestAnimationFrame(loop);
            }

            function stop() {
                if (rafId != null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                }
            }

            resizeCanvas();
            window.addEventListener('resize', () => {
                stop();
                resizeCanvas();
                if (!prefersReduced) start();
            });

            document.addEventListener('visibilitychange', () => {
                if (document.hidden) stop(); else if (!prefersReduced) start();
            });

            if (!prefersReduced) {
                start();
            } else {
                ctx.fillStyle = 'rgba(13, 43, 78, 0.25)';
                ctx.fillRect(0, 0, container.clientWidth, container.clientHeight);
                ctx.fillStyle = PY_BLUE;
                for (let i = 0; i < 80; i++) {
                    const glyph = glyphs[Math.floor(Math.random() * glyphs.length)];
                    const x = Math.random() * container.clientWidth;
                    const y = Math.random() * container.clientHeight;
                    ctx.fillText(glyph, x, y);
                }
            }
        });
    </script>
</body>

</html>
