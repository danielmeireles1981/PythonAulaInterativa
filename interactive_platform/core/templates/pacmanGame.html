<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Python - Python vs Bugs</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #1abc9c;
            --success: #2ecc71;
            --danger: #e74c3c;
            --info: #3498db;
            --pacman-yellow: #FFD43B; /* Amarelo espec√≠fico para o Pac-Man */
            --bug-red: var(--danger);
            --bug-purple: #9b59b6;
            --bug-orange: #f39c12;
            --bug-pink: #e91e63;
            --bug-cyan: #0891B2; /* Nova cor para o Phantom Bug */
            --energy-green: var(--success);
            --wall-color: #2D3748;
            --path-color: #1a202c;
        }
        
        .main-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            width: 100%;
            max-width: 1400px; /* Aumentado para acomodar os dois lados */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, var(--primary), #1a202c);
            color: #ecf0f1;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 15px;
            width: 100%;
            max-width: 760px;
        }
        
        h1 {
            color: var(--secondary);
            font-size: 1.2rem;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(26, 188, 156, 0.5);
        }
        
        .subtitle {
            color: var(--info);
            font-size: 1rem;
        }
        
        .game-ui {
            display: flex;
            justify-content: space-between;
            width: 960px; /* Largura fixa para alinhar com o canvas */
            max-width: 760px;
            margin-bottom: 15px;
            background: rgba(44, 62, 80, 0.3);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--primary);
            gap: 10px;
        }
        
        .ui-item {
            text-align: center;
            flex: 1;
        }
        
        .ui-label {
            color: var(--secondary);
            font-size: 0.8rem;
            margin-bottom: 3px;
        }
        
        .ui-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ecf0f1;
        }
        
        .game-container {
            position: relative;
            width: 1120px; /* Largura fixa (40 tiles * 28px) */
            height: 700px; /* Altura fixa (25 tiles * 28px) */
            margin-bottom: 15px;
            border: 2px solid var(--primary);
            border-radius: 8px;
            overflow: hidden;
            background: var(--path-color);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
        }
        
        #gameCanvas {
            background: var(--path-color);
            width: 100%;
            display: block;
        }
        
        .controls {
            display: flex;
            gap: 12px;
            flex-direction: column;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        button {
            background: linear-gradient(135deg, var(--secondary), var(--success));
            color: var(--primary); 
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        
        .instructions {
            background: rgba(44, 62, 80, 0.3);
            padding: 12px;
            padding-bottom: 20px;
            border-radius: 8px; 
            flex: 1; /* Ocupa o espa√ßo restante */
            min-width: 250px; /* Largura m√≠nima */
            max-width: 760px;
            border: 1px solid var(--primary);
        }
        
        .instructions h3 {
            color: var(--secondary);
            margin-bottom: 8px;
            font-size: 1rem;
        }
        
        .instructions ul {
            list-style-type: none;
            padding-left: 0;
        }
        
        .instructions li {
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            font-size: 0.85rem;
        }
        
        .instructions li::before {
            content: "üêç";
            margin-right: 8px;
        }
        
        .game-over {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .game-over-content {
            background: linear-gradient(135deg, var(--primary), #233140);
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            border: 2px solid var(--secondary);
            box-shadow: 0 0 20px rgba(26, 188, 156, 0.3);
        }
        
        .game-over-content h2 {
            color: var(--secondary);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        .game-over-content p {
            margin-bottom: 15px;
            font-size: 1rem;
        }
        
        .python-logo {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px;
            background: linear-gradient(135deg, var(--primary), var(--info));
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .python-logo::before {
            content: "";
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: var(--secondary);
            border-radius: 50%;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.8rem;
        }
        
        @media (max-width: 800px) {
            .game-ui, .instructions {
                width: 95%;
                max-width: 95%;
            }
            
            .game-container {
                width: 100%;
                max-width: 100%;
                height: auto;
            }

            .game-container {
                height: auto;
            }
            
            h1 {
                font-size: 1.6rem;
            }
            
            .game-ui {
                flex-wrap: wrap;
            }
            
            .ui-item {
                flex: 1 0 45%;
                margin-bottom: 5px;
            }
            
            .legend {
                gap: 10px;
            }
            
            .legend-item {
                font-size: 0.7rem;
            }

            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .instructions {
                margin-top: 15px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            
            .game-container {
                height: 350px;
            }
            
            .ui-value {
                font-size: 1rem;
            }
            
            button {
                padding: 8px 16px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üêç Pac-Python üêç</h1>
        <p class="subtitle">Python vs Bugs do Sistema! Colete energia de otimiza√ß√£o!</p>
    </div>
    
    <div class="game-ui">
        <div class="ui-item">
            <div class="ui-label">Pontua√ß√£o üèÜ</div>
            <div class="ui-value" id="score">0</div>
        </div>
        <div class="ui-item">
            <div class="ui-label">Vidas ‚ù§Ô∏è</div>
            <div class="ui-value" id="lives">3</div>
        </div>
        <div class="ui-item">
            <div class="ui-label">Energia ‚ö°</div>
            <div class="ui-value" id="energy">0s</div>
        </div>
        <div class="ui-item">
            <div class="ui-label">Pac-Dots üìç</div>
            <div class="ui-value" id="dots">0/150</div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item"><span style="color: var(--secondary)">üêç</span> Python (Jogador)</div>
        <div class="legend-item"><span style="color: var(--bug-red)">üêõ</span> Bug Cr√≠tico</div>
        <div class="legend-item"><span style="color: var(--bug-purple)">ü¶†</span> Bug de Mem√≥ria</div>
        <div class="legend-item"><span style="color: var(--bug-orange)">üí•</span> Bug de Sistema</div>
        <div class="legend-item"><span style="color: var(--bug-pink)">üåÄ</span> Bug L√≥gico</div>
        <div class="legend-item"><span style="color: var(--bug-cyan)">üëª</span> Phantom Bug</div>
        <div class="legend-item"><span style="color: var(--energy-green)">‚ö°</span> Energia de Otimiza√ß√£o</div>
    </div>
    
    <div class="main-container">
        <div>
            <div class="game-container">
                <canvas id="gameCanvas" width="760" height="475"></canvas>
            </div>
        </div>
        
        <div class="instructions">
            <h3>Como Jogar:</h3>
            <ul>
                <li>Use as teclas ‚Üê ‚Üë ‚Üí ‚Üì para mover o Python üêç</li>
                <li>Colete todos os Pac-Dots para avan√ßar de n√≠vel</li>
                <li>Evite os bugs do sistema üêõü¶†üí•üåÄ</li>
                <li>Colete energias ‚ö° para ficar temporariamente invenc√≠vel</li>
                <li>Quando com energia, voc√™ pode comer os bugs por pontos extras!</li>
                <li>Cada bug comido vale 200 pontos durante a energia</li>
            </ul>
            <div class="controls" style="margin-top: 20px;">
                <button id="start-btn">üéÆ Iniciar Jogo</button>
                <button id="pause-btn">‚è∏Ô∏è Pausar</button>
                <button id="reset-btn">üîÑ Reiniciar</button>
            </div>
        </div>
    </div>
    
    <div class="game-over" id="game-over">
        <div class="game-over-content">
            <div class="python-logo"></div>
            <h2>üéØ Fim de Jogo! üéØ</h2>
            <p>üèÜ Sua pontua√ß√£o final: <span id="final-score">0</span></p>
            <p>‚≠ê N√≠vel alcan√ßado: <span id="final-level">1</span></p>
            <button id="restart-btn">üîÑ Jogar Novamente</button>
        </div>
    </div>

    <script>
        // Configura√ß√£o do jogo - CANVAS REDIMENSIONADO
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Elementos da UI
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const energyDisplay = document.getElementById('energy');
        const dotsDisplay = document.getElementById('dots');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const gameOverModal = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const finalLevelDisplay = document.getElementById('final-level');
        const restartBtn = document.getElementById('restart-btn');
        
        // Constantes do jogo - AJUSTADAS PARA O NOVO TAMANHO
        const TILE_SIZE = 28;
        const GRID_WIDTH = 40;
        const GRID_HEIGHT = 25;
        const PLAYER_SPEED = 2;
        const GHOST_SPEED = 2;
        const ENERGY_DURATION = 8;
        
        // Cores
        const COLORS = {
            wall: '#2D3748',
            path: '#1a202c',
            dot: '#3498db',
            player: '#FFD43B',
            energy: '#FFD43B',
            ghosts: {
                red: '#e74c3c',
                purple: '#9b59b6',
                orange: '#f39c12',
                pink: '#e91e63'
            },
            phantom: 'var(--info)'
        };
        
        // Estado do jogo
        let score = 0;
        let lives = 3;
        let level = 1;
        let dotsCollected = 0;
        let totalDots = 0;
        let energyTime = 0;
        let gameRunning = false;
        let gamePaused = false;
        let gameOver = false;
        
        // Elementos do jogo
        let player = { x: 0, y: 0, direction: 'right', nextDirection: 'right' };
        let ghosts = [];
        let dots = [];
        let energies = [];
        let walls = new Set();
        
        // Sistema de movimento
        let playerMoveCounter = 0; // Removido, movimento baseado em requestAnimationFrame
        let ghostMoveCounter = 0; 
        const PLAYER_MOVE_DELAY = 8;
        const GHOST_MOVE_DELAY = 12;
        
        // Cache para detec√ß√£o de paredes
        let wallCache = new Map();
        
        // Labirinto REDESENHADO para caber no canvas
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,1,1,1,2,1],
            [1,3,1,1,1,2,1,1,1,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,1,1,2,1,1,1,3,1],
            [1,2,1,1,1,2,1,1,1,2,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,1,1,2,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,2,1],
            [1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,2,1],
            [1,2,1,1,1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,2,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,2,1,1,1,2,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,2,1,2,1,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,1,2,1,1,1,2,1,0,0,1,1,1,1,1,1,1,1,0,1,2,1,1,1,2,1,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,1,2,1,2,1,1,1,2,1,0,0,0,0,0,0,0,0,0,0,0,1,2,1,1,1,2,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,2,1,2,1,1,1,2,1,0,0,1,1,1,1,1,1,1,1,0,1,2,1,1,1,2,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,2,1,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,0,0,0,0,0,0,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,1,1,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,1,1,1,2,1],
            [1,3,1,1,1,2,1,1,1,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,1,1,2,1,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        // Inicializar o jogo
        function initGame() {
            player = { x: 1, y: 1, direction: 'right', nextDirection: 'right' };
            ghosts = [];
            dots = [];
            energies = [];
            walls = new Set();
            dotsCollected = 0;
            totalDots = 0;
            playerMoveCounter = 0;
            ghostMoveCounter = 0;
            wallCache.clear();
            
            // Parse do labirinto
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = maze[y][x];
                    if (maze[y][x] === 1) {
                        walls.add(`${x},${y}`);
                        wallCache.set(`${x},${y}`, true);
                    } else if (cell === 2) {
                        dots.push({ x, y });
                        totalDots++;
                    } else if (cell === 3) {
                        energies.push({ x, y });
                    }
                }
            }
            
            // Criar fantasmas (bugs)
            ghosts = [
                { x: 18, y: 12, type: 'red', direction: 'up', lastDecision: 0 },
                { x: 19, y: 12, type: 'purple', direction: 'up', lastDecision: 10 },
                { x: 20, y: 12, type: 'orange', direction: 'up', lastDecision: 20 },
                { x: 21, y: 12, type: 'pink', direction: 'up', lastDecision: 30 },
                { x: 19, y: 11, type: 'phantom', direction: 'up', lastDecision: 0, teleportTimer: 10 } // Novo bug
            ];
            
            updateUI();
        }
        
        // Atualizar UI
        function updateUI() {
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            energyDisplay.textContent = energyTime > 0 ? Math.ceil(energyTime) + 's' : '0s';
            dotsDisplay.textContent = dotsCollected + '/' + totalDots;
        }
        
        // Desenhar o jogo
        function draw() {
            // Limpar canvas
            ctx.fillStyle = COLORS.path;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Desenhar paredes
            ctx.fillStyle = COLORS.wall;
            walls.forEach(wallKey => {
                const [x, y] = wallKey.split(',').map(Number);
                ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });
            // Desenhar dots
            ctx.fillStyle = COLORS.dot;
            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(
                    dot.x * TILE_SIZE + TILE_SIZE / 2,
                    dot.y * TILE_SIZE + TILE_SIZE / 2,
                    3, 0, Math.PI * 2
                );
                ctx.fill();
            });
            
            // Desenhar energias com anima√ß√£o simples
            const energyPulse = Math.sin(Date.now() / 200) * 2 + 6;
            ctx.fillStyle = COLORS.energy;
            energies.forEach(energy => {
                ctx.beginPath();
                ctx.arc(
                    energy.x * TILE_SIZE + TILE_SIZE / 2,
                    energy.y * TILE_SIZE + TILE_SIZE / 2,
                    energyPulse, 0, Math.PI * 2
                );
                ctx.fill();
            });
            
            // Desenhar jogador (Python)
            const playerX = player.x * TILE_SIZE;
            const playerY = player.y * TILE_SIZE;
            
            ctx.fillStyle = energyTime > 0 ? 'color-mix(in srgb, var(--success) 80%, white 20%)' : COLORS.player; // Cor amarela normal, verde quando com energia
            ctx.beginPath();
            ctx.arc(
                playerX + TILE_SIZE / 2, 
                playerY + TILE_SIZE / 2,
                TILE_SIZE / 2 - 2, 0, Math.PI * 2
            );
            ctx.fill();
            
            // Boca do Pac-Python animada
            const mouthOpen = 0.3 + Math.sin(Date.now() / 100) * 0.1;
            ctx.fillStyle = COLORS.path; // Cor do fundo para a boca
            let startAngle, endAngle;
            switch(player.direction) {
                case 'right':
                    startAngle = mouthOpen * Math.PI;
                    endAngle = (2 - mouthOpen) * Math.PI;
                    break;
                case 'left':
                    startAngle = (1 + mouthOpen) * Math.PI;
                    endAngle = (1 - mouthOpen) * Math.PI;
                    break;
                case 'up':
                    startAngle = (1.5 + mouthOpen) * Math.PI;
                    endAngle = (1.5 - mouthOpen) * Math.PI;
                    break;
                case 'down':
                    startAngle = (0.5 + mouthOpen) * Math.PI;
                    endAngle = (0.5 - mouthOpen) * Math.PI;
                    break;
            }
            ctx.beginPath();
            ctx.moveTo(
                playerX + TILE_SIZE / 2, 
                playerY + TILE_SIZE / 2
            );
            ctx.arc(
                playerX + TILE_SIZE / 2, 
                playerY + TILE_SIZE / 2,
                TILE_SIZE / 2 - 2, startAngle, endAngle
            );
            ctx.closePath();
            ctx.fill();
            
            // Desenhar fantasmas (bugs)
            ghosts.forEach(ghost => {
                const ghostX = ghost.x * TILE_SIZE;
                const ghostY = ghost.y * TILE_SIZE;
                
                let ghostColor;
                let ghostEmoji;
                
                switch(ghost.type) {
                    case 'red':
                        ghostColor = COLORS.ghosts.red;
                        ghostEmoji = 'üêõ';
                        break;
                    case 'purple':
                        ghostColor = COLORS.ghosts.purple;
                        ghostEmoji = 'ü¶†';
                        break;
                    case 'orange':
                        ghostColor = COLORS.ghosts.orange;
                        ghostEmoji = 'üí•';
                        break;
                    case 'pink':
                        ghostColor = COLORS.ghosts.pink;
                        ghostEmoji = 'üåÄ';
                        break;
                    case 'phantom':
                        ghostColor = COLORS.ghosts.phantom;
                        ghostEmoji = 'üëª';
                        break;
                }
                
                // Se o jogador tem energia, os fantasmas ficam azuis (vulner√°veis)
                if (energyTime > 0) {
                    ghostColor = 'var(--info)'; // Azul vulner√°vel
                    // Efeito de piscar quando vulner√°vel
                    if (Math.floor(Date.now() / 200) % 2 === 0) {
                        ghostColor = 'white';
                    }
                }
                
                ctx.fillStyle = ghostColor;
                ctx.beginPath();
                // Corpo do fantasma
                ctx.arc(ghostX + TILE_SIZE / 2, ghostY + TILE_SIZE / 2, TILE_SIZE / 2 - 2, Math.PI, 0);
                ctx.lineTo(ghostX + TILE_SIZE - 2, ghostY + TILE_SIZE - 2);
                ctx.lineTo(ghostX + TILE_SIZE / 2, ghostY + TILE_SIZE - 6);
                ctx.lineTo(ghostX + 2, ghostY + TILE_SIZE - 2);
                ctx.fill();
                
                // Emoji do bug
                ctx.font = '14px Arial';
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    ghostEmoji,
                    ghostX + TILE_SIZE / 2, 
                    ghostY + TILE_SIZE / 2
                );
            });
        }
        
        // Resto do c√≥digo permanece igual...
        // [O c√≥digo restante das fun√ß√µes update, movePlayer, moveGhosts, checkCollisions, etc. permanece igual ao anterior]
        
        // Atualizar o jogo
        function update() {
            if (!gameRunning || gamePaused || gameOver) return;
            
            playerMoveCounter++;
            if (playerMoveCounter >= PLAYER_MOVE_DELAY) {
                movePlayer();
                playerMoveCounter = 0;
            }
            
            // Mover fantasmas com delay
            ghostMoveCounter++;
            if (ghostMoveCounter >= GHOST_MOVE_DELAY) {
                moveGhosts();
                ghostMoveCounter = 0;
            }
            
            // Verificar colis√µes
            checkCollisions();
            
            // Atualizar energia
            if (energyTime > 0) {
                energyTime -= 0.016;
                if (energyTime <= 0) {
                    energyTime = 0;
                }
            }
            
            // Verificar vit√≥ria
            if (dotsCollected >= totalDots) {
                levelUp();
            }
            
            updateUI();
        }
        
        // Mover jogador
        function movePlayer() {
            const directions = {
                'up': { x: 0, y: -1 },
                'down': { x: 0, y: 1 },
                'left': { x: -1, y: 0 },
                'right': { x: 1, y: 0 }
            };
            
            const nextDir = directions[player.nextDirection];
            const nextX = player.x + nextDir.x;
            const nextY = player.y + nextDir.y;
            
            if (!isWall(nextX, nextY)) {
                player.direction = player.nextDirection;
            }
            
            const currentDir = directions[player.direction];
            const newX = player.x + currentDir.x;
            const newY = player.y + currentDir.y;
            
            if (!isWall(newX, newY)) {
                player.x = newX;
                player.y = newY;
                
                if (player.x < 0) player.x = GRID_WIDTH - 1;
                if (player.x >= GRID_WIDTH) player.x = 0;
            }
        }
        
        // Mover fantasmas
        function moveGhosts() {
            const playerDirVec = {
                'up': { x: 0, y: -1 }, 'down': { x: 0, y: 1 },
                'left': { x: -1, y: 0 }, 'right': { x: 1, y: 0 }
            }[player.direction];

            ghosts.forEach(ghost => {
                // L√≥gica do Phantom Bug
                if (ghost.type === 'phantom') {
                    ghost.teleportTimer -= 0.016; // Reduz o timer
                    if (ghost.teleportTimer <= 0) {
                        // Teleporta para um local aleat√≥rio e v√°lido
                        const validCells = [];
                        for (let y = 0; y < GRID_HEIGHT; y++) {
                            for (let x = 0; x < GRID_WIDTH; x++) {
                                if (!isWall(x, y)) validCells.push({x, y});
                            }
                        }
                        const newPos = validCells[Math.floor(Math.random() * validCells.length)];
                        ghost.x = newPos.x;
                        ghost.y = newPos.y;
                        ghost.teleportTimer = 10 + Math.random() * 5; // Reseta o timer
                        return; // Pula o movimento normal neste frame
                    }
                }

                // L√≥gica de decis√£o de movimento em interse√ß√µes
                const possibleMoves = getPossibleMoves(ghost);
                if (possibleMoves.length > 1 || ghost.lastDecision > 10) {
                    ghost.lastDecision = 0;

                    let targetX = player.x;
                    let targetY = player.y;

                    // L√≥gica de alvo espec√≠fica para cada bug
                    switch (ghost.type) {
                        case 'pink': // Pinky: mira 4 casas √† frente do jogador
                            targetX += playerDirVec.x * 4;
                            targetY += playerDirVec.y * 4;
                            break;
                        case 'orange': // Clyde: se estiver longe, persegue; se perto, foge
                            const distance = Math.sqrt(Math.pow(player.x - ghost.x, 2) + Math.pow(player.y - ghost.y, 2));
                            if (distance < 8) {
                                targetX = 1; // Canto inferior esquerdo
                                targetY = GRID_HEIGHT - 2;
                            }
                            break;
                        case 'purple': // Inky: l√≥gica mais complexa
                            const blinky = ghosts.find(g => g.type === 'red');
                            if (blinky) {
                                const offsetX = (player.x + playerDirVec.x * 2) - blinky.x;
                                const offsetY = (player.y + playerDirVec.y * 2) - blinky.y;
                                targetX = blinky.x + offsetX * 2;
                                targetY = blinky.y + offsetY * 2;
                            }
                            break;
                        // 'red' (Blinky) e 'phantom' usam o alvo padr√£o (o jogador)
                    }

                    // Se estiver com energia, os bugs fogem
                    if (energyTime > 0) {
                        targetX = Math.random() > 0.5 ? 1 : GRID_WIDTH - 2;
                        targetY = Math.random() > 0.5 ? 1 : GRID_HEIGHT - 2;
                    }

                    // Escolhe a melhor dire√ß√£o para se aproximar do alvo
                    let bestDir = ghost.direction;
                    let minDistance = Infinity;

                    for (const move of possibleMoves) {
                        const newX = ghost.x + move.vec.x;
                        const newY = ghost.y + move.vec.y;
                        const distanceToTarget = Math.sqrt(Math.pow(targetX - newX, 2) + Math.pow(targetY - newY, 2));

                        if (distanceToTarget < minDistance) {
                            minDistance = distanceToTarget;
                            bestDir = move.dir;
                        }
                    }
                    ghost.direction = bestDir;
                }
                ghost.lastDecision++;
                
                const dirVec = {
                    'up': { x: 0, y: -1 },
                    'down': { x: 0, y: 1 },
                    'left': { x: -1, y: 0 },
                    'right': { x: 1, y: 0 }
                }[ghost.direction];
                
                const newX = ghost.x + dirVec.x;
                const newY = ghost.y + dirVec.y;
                
                if (!isWall(newX, newY)) {
                    ghost.x = newX;
                    ghost.y = newY;
                }
            });
        }

        function getPossibleMoves(character) {
            const moves = [];
            const directions = {
                'up': { x: 0, y: -1 }, 'down': { x: 0, y: 1 },
                'left': { x: -1, y: 0 }, 'right': { x: 1, y: 0 }
            };
            const opposite = {
                'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left'
            };

            for (const dir in directions) {
                // Impede o bug de fazer uma curva de 180 graus
                if (dir === opposite[character.direction]) {
                    continue;
                }

                const vec = directions[dir];
                if (!isWall(character.x + vec.x, character.y + vec.y)) {
                    moves.push({ dir, vec });
                }
            }
            return moves;
        }
        
        // Verificar colis√µes
        function checkCollisions() {
            for (let i = dots.length - 1; i >= 0; i--) {
                if (dots[i].x === player.x && dots[i].y === player.y) {
                    dots.splice(i, 1);
                    dotsCollected++;
                    score += 10;
                }
            }
            
            for (let i = energies.length - 1; i >= 0; i--) {
                if (energies[i].x === player.x && energies[i].y === player.y) {
                    energies.splice(i, 1);
                    energyTime = ENERGY_DURATION;
                    score += 50;
                }
            }
            
            ghosts.forEach(ghost => {
                if (ghost.x === player.x && ghost.y === player.y) {
                    if (energyTime > 0) {
                        ghost.x = 19; // Manda de volta para o esconderijo
                        ghost.y = 12;
                        score += 200;
                    } else {
                        lives--;
                        if (lives <= 0) {
                            gameOver = true;
                            showGameOver();
                        } else {
                            player.x = 1;
                            player.y = 1;
                            player.direction = 'right';
                            player.nextDirection = 'right';
                        }
                    }
                }
            });
        }
        
        // Verificar se √© parede
        function isWall(x, y) {
            const key = `${x},${y}`;
            if (wallCache.has(key)) {
                return true;
            }
            return false;
        }
        
        // Subir de n√≠vel
        function levelUp() {
            level++;
            score += 1000;
            initGame();
        }
        
        // Mostrar game over
        function showGameOver() {
            finalScoreDisplay.textContent = score;
            finalLevelDisplay.textContent = level;
            gameOverModal.style.display = 'flex';
        }
        
        // Loop do jogo
        function gameLoop() {
            update();
            draw();
            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Event listeners
        startBtn.addEventListener('click', () => {
            if (!gameRunning) {
                // Ajusta o tamanho do canvas dinamicamente
                canvas.width = GRID_WIDTH * TILE_SIZE;
                canvas.height = GRID_HEIGHT * TILE_SIZE;

                gameRunning = true;
                gamePaused = false;
                initGame();
                gameLoop();
            }
        });
        
        pauseBtn.addEventListener('click', () => {
            if (gameRunning) {
                gamePaused = !gamePaused;
                pauseBtn.textContent = gamePaused ? '‚ñ∂Ô∏è Continuar' : '‚è∏Ô∏è Pausar';
            }
        });
        
        resetBtn.addEventListener('click', () => {
            // Ajusta o tamanho do canvas dinamicamente
            canvas.width = GRID_WIDTH * TILE_SIZE;
            canvas.height = GRID_HEIGHT * TILE_SIZE;

            score = 0;
            lives = 3;
            level = 1;
            gameRunning = false;
            gamePaused = false;
            gameOver = false;
            gameOverModal.style.display = 'none';
            initGame();
            draw();
        });
        
        restartBtn.addEventListener('click', () => {
            // Ajusta o tamanho do canvas dinamicamente
            canvas.width = GRID_WIDTH * TILE_SIZE;
            canvas.height = GRID_HEIGHT * TILE_SIZE;

            score = 0;
            lives = 3;
            level = 1;
            gameRunning = true;
            gamePaused = false;
            gameOver = false;
            gameOverModal.style.display = 'none';
            initGame();
        });
        
        // Controles do teclado
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gamePaused) return;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                    player.nextDirection = 'up';
                    break;
                case 'ArrowDown':
                case 's':
                    player.nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                case 'a':
                    player.nextDirection = 'left';
                    break;
                case 'ArrowRight':
                case 'd':
                    player.nextDirection = 'right';
                    break;
            }
        });
        
        // Inicializar
        // Ajusta o tamanho do canvas dinamicamente na carga inicial
        canvas.width = GRID_WIDTH * TILE_SIZE;
        canvas.height = GRID_HEIGHT * TILE_SIZE;

        initGame();
        draw();
    </script>
</body>
</html>