<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Python Quiz</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #1abc9c;
            --success: #2ecc71;
            --danger: #e74c3c;
            --info: #3498db;
            --pacman-yellow: #FFD43B;
            --bug-red: var(--danger);
            --bug-purple: #9b59b6;
            --bug-orange: #f39c12;
            --bug-pink: #e91e63;
            --energy-green: var(--success);
            --wall-color: #2D3748;
            --path-color: #1a202c;
        }
        
        .main-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            width: 100%;
            max-width: 1400px; /* Aumentado para acomodar os dois lados */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, var(--primary), #1a202c);
            color: #ecf0f1;
            font-family: 'Roboto', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 15px;
            width: 100%;
            max-width: 760px;
        }
        
        h1 {
            font-family: 'Orbitron', sans-serif;
            color: var(--secondary);
            font-size: 1.8rem;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(26, 188, 156, 0.5);
        }
        
        .subtitle {
            color: var(--info);
            font-size: 1rem;
        }
        
        .game-ui {
            display: flex;
            width: 960px; /* Largura fixa para alinhar com o canvas */
            max-width: 760px;
            margin-bottom: 15px;
            background: rgba(44, 62, 80, 0.3);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--primary);
            gap: 15px;
        }
        
        .ui-item {
            text-align: center;
            flex: 1;
        }
        
        .ui-label {
            font-family: 'Orbitron', sans-serif;
            color: var(--secondary);
            font-size: 0.8rem;
            margin-bottom: 3px;
        }
        
        .ui-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: #ecf0f1;
        }
        
        .game-container {
            position: relative;
            width: 1120px; /* Largura fixa (40 tiles * 28px) */
            height: 700px; /* Altura fixa (25 tiles * 28px) */
            margin-bottom: 15px;
            border: 2px solid var(--primary);
            border-radius: 8px;
            overflow: hidden;
            background: var(--path-color);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
        }
        
        #gameCanvas {
            background: var(--path-color);
            width: 100%;
            display: block;
        }
        
        .controls {
            display: flex;
            gap: 12px;
            flex-direction: column;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        button {
            background: linear-gradient(135deg, var(--secondary), var(--success));
            color: var(--primary); 
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        
        .instructions {
            background: rgba(44, 62, 80, 0.3);
            padding: 12px;
            padding-bottom: 20px;
            border-radius: 8px;
            flex: 1; /* Ocupa o espa√ßo restante */
            min-width: 250px; /* Largura m√≠nima */
            max-width: 760px;
            border: 1px solid var(--primary);
            text-align: left; /* Alinha o texto √† esquerda */
        }
        
        .instructions h3 {
            font-family: 'Orbitron', sans-serif;
            color: var(--secondary);
            margin-bottom: 8px;
            font-size: 1rem;
        }
        
        .instructions ul {
            list-style-type: none;
            padding-left: 0;
        }
        
        .instructions li {
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            font-size: 0.85rem;
        }
        
        .instructions li::before {
            content: "üêç";
            margin-right: 8px;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: linear-gradient(135deg, var(--primary), #233140);
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            border: 2px solid var(--secondary);
            box-shadow: 0 0 20px rgba(26, 188, 156, 0.3);
        }
        
        .modal-content h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--secondary);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        .modal-content p {
            margin-bottom: 15px;
            font-size: 1rem;
        }
        
        .python-logo {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px;
            background: linear-gradient(135deg, var(--primary), var(--info));
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .python-logo::before {
            content: "";
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: var(--secondary);
            border-radius: 50%;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.8rem;
        }

        .answers {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .answer-btn {
            background: var(--info);
            color: white;
        }

        .answer-btn:hover {
            background: var(--primary);
            transform: translateY(-2px);
        }
        
        @media (max-width: 800px) {
            .game-ui, .instructions {
                width: 95%;
                max-width: 95%;
            }
            
            .game-container {
                width: 100%;
                max-width: 100%;
                height: auto;
            }

            .game-container {
                height: auto;
            }
            
            h1 {
                font-size: 1.6rem;
            }
            
            .game-ui {
                flex-wrap: wrap;
            }
            
            .ui-item {
                flex: 1 0 45%;
                margin-bottom: 5px;
            }
            
            .legend {
                gap: 10px;
            }
            
            .legend-item {
                font-size: 0.7rem;
            }

            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .instructions {
                margin-top: 15px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            
            .game-container {
                height: 350px;
            }
            
            .ui-value {
                font-size: 1rem;
            }
            
            button {
                padding: 8px 16px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üêç Pac-Python üêç</h1>
        <p class="subtitle">Colete os bits de dados, responda √†s perguntas e fuja dos bugs!</p>
    </div>
    
    <div class="game-ui">
        <div class="ui-item">
            <div class="ui-label">Pontua√ß√£o üèÜ</div>
            <div class="ui-value" id="score">0</div>
        </div>
        <div class="ui-item">
            <div class="ui-label">Vidas ‚ù§Ô∏è</div>
            <div class="ui-value" id="lives">3</div>
        </div>
        <div class="ui-item">
            <div class="ui-label">Otimiza√ß√£o ‚ö°</div>
            <div class="ui-value" id="energy">0s</div>
        </div>
        <div class="ui-item">
            <div class="ui-label">Data Bits üíæ</div>
            <div class="ui-value" id="dots">0/150</div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item"><span style="color: var(--secondary)">üêç</span> Python (Jogador)</div>
        <div class="legend-item"><span style="color: var(--bug-red)">üêõ</span> Bug Cr√≠tico</div>
        <div class="legend-item"><span style="color: var(--bug-purple)">ü¶†</span> Bug de Mem√≥ria</div>
        <div class="legend-item"><span style="color: var(--bug-orange)">üí•</span> Bug de Sistema</div>
        <div class="legend-item"><span style="color: var(--bug-pink)">üåÄ</span> Bug de L√≥gica</div>
        <div class="legend-item"><span style="color: var(--info)">‚ùì</span> M√≥dulo de Otimiza√ß√£o</div>
        <div class="legend-item"><span style="color: var(--success)">üöÄ</span> Speed Boost</div>
        <div class="legend-item"><span style="color: var(--danger)">‚ùÑÔ∏è</span> Freeze</div>
    </div>
    
    <div class="main-container">
        <div>
            <div class="game-container">
                <canvas id="gameCanvas" width="760" height="475"></canvas>
            </div>
        </div>
        
        <div class="instructions">
            <h3>Como Jogar:</h3>
            <ul>
                <li>Use as teclas ‚Üê ‚Üë ‚Üí ‚Üì para mover o Python üêç</li>
                <li>Colete todos os Data Bits (pontos) para avan√ßar de n√≠vel.</li>
                <li>Evite os Bugs do sistema (üêõü¶†üí•üåÄ).</li>
                <li>Colete um M√≥dulo de Otimiza√ß√£o (‚ùì) para pausar o jogo e responder a uma pergunta.</li>
                <li>Colete power-ups como Speed Boost (üöÄ) e Freeze (‚ùÑÔ∏è) para ganhar vantagens!</li>
                <li>Acerte a pergunta para ganhar poder de otimiza√ß√£o (invencibilidade) e devorar os bugs por pontos extras!</li>
                <li>Cada bug comido vale 200 pontos durante a energia</li>
            </ul>
            <div class="controls" style="margin-top: 20px;">
                <button id="start-btn">üéÆ Iniciar Jogo</button>
                <button id="pause-btn">‚è∏Ô∏è Pausar</button>
                <button id="reset-btn">üîÑ Reiniciar</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="game-over">
        <div class="modal-content">
            <div class="python-logo"></div>
            <h2>üéØ Fim de Jogo! üéØ</h2>
            <p>üèÜ Sua pontua√ß√£o final: <span id="final-score">0</span></p>
            <p>‚≠ê N√≠vel alcan√ßado: <span id="final-level">1</span></p>
            <button id="restart-btn">üîÑ Jogar Novamente</button>
        </div>
    </div>

    <!-- NOVO: Modal de Perguntas -->
    <div class="modal" id="question-modal">
        <div class="modal-content">
            <h2>üêç Pergunta Python üêç</h2>
            <p id="question-text"></p>
            <div class="answers" id="answers-container"></div>
            <p>‚è∞ Tempo restante: <span id="question-time-left">15</span>s</p>
        </div>
    </div>

    <script>
        // Configura√ß√£o do jogo - CANVAS REDIMENSIONADO
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Elementos da UI
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const energyDisplay = document.getElementById('energy');
        const dotsDisplay = document.getElementById('dots');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const gameOverModal = document.getElementById('game-over'); // Modal de Fim de Jogo
        const questionModal = document.getElementById('question-modal'); // Novo Modal de Perguntas
        const questionText = document.getElementById('question-text');
        const answersContainer = document.getElementById('answers-container');
        const questionTimeLeftDisplay = document.getElementById('question-time-left');
        const finalScoreDisplay = document.getElementById('final-score');
        const finalLevelDisplay = document.getElementById('final-level');
        const restartBtn = document.getElementById('restart-btn');
        
        // Constantes do jogo - AJUSTADAS PARA O NOVO TAMANHO
        const TILE_SIZE = 28;
        const GRID_WIDTH = 40;
        const GRID_HEIGHT = 25;
        let playerSpeed = 0.15; // Velocidade base do jogador (tempo para cruzar uma c√©lula)
        let ghostSpeed = 0.25;  // Velocidade base dos fantasmas
        const ENERGY_DURATION = 8;
        const QUESTION_TIME = 15;
        
        // Cores
        const COLORS = {
            wall: '#2D3748',
            path: '#1a202c',
            dot: 'var(--info)',
            player: 'var(--pacman-yellow)',
            questionItem: 'var(--secondary)',
            ghosts: {
                red: '#e74c3c',
                purple: '#9b59b6',
                orange: '#f39c12',
                pink: '#e91e63'
            },
            vulnerable: 'var(--info)'
        };

        // Perguntas
        const pythonQuestions = [
            { question: "Qual fun√ß√£o exibe texto no console?", answers: ["print()", "echo()", "display()", "show()"], correct: 0 },
            { question: "Como se declara uma lista?", answers: ["{1,2}", "[1,2]", "(1,2)", "<1,2>"], correct: 1 },
            { question: "Qual palavra-chave define uma fun√ß√£o?", answers: ["function", "def", "func", "define"], correct: 1 },
            { question: "Qual operador verifica igualdade de valor?", answers: ["=", "==", "===", "is"], correct: 1 },
            { question: "Como se inicia um coment√°rio de uma linha?", answers: ["//", "#", "/*", "--"], correct: 1 },
            { question: "Qual estrutura de dados √© imut√°vel?", answers: ["Lista", "Dicion√°rio", "Set", "Tupla"], correct: 3 },
            { question: "O que `len()` faz em uma lista?", answers: ["Soma os itens", "Retorna o tamanho", "Inverte a lista", "Ordena a lista"], correct: 1 },
            { question: "Qual o resultado de `10 % 3`?", answers: ["3", "3.33", "1", "0"], correct: 2 },
            { question: "Qual o operador para exponencia√ß√£o?", answers: ["^", "**", "pow", "exp"], correct: 1 },
            { question: "Qual cole√ß√£o n√£o permite itens duplicados?", answers: ["Lista", "Tupla", "Dicion√°rio", "Set (Conjunto)"], correct: 3 }
        ];
        let currentQuestion = null;
        let questionTimer;
        
        // Estado do jogo
        let score = 0;
        let lives = 3;
        let level = 1;
        let dotsCollected = 0;
        let totalDots = 0;
        let energyTime = 0;
        let gameRunning = false;
        let gamePaused = false;
        
        // Elementos do jogo
        let player = { x: 0, y: 0, direction: 'right', nextDirection: 'right', visualX: 0, visualY: 0, moveProgress: 0 };
        let ghosts = [];
        let dots = [];
        let questionItems = []; // Substitui 'energies'
        let powerUps = []; // NOVO: para speed boost e freeze
        let walls = new Set();
        
        // Efeitos de Power-up
        let speedBoostTime = 0;
        let freezeTime = 0;
        
        // Cache para detec√ß√£o de paredes
        let wallCache = new Map();

        // Labirinto REDESENHADO para caber no canvas
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,1,1,1,2,1],
            [1,3,1,1,1,2,1,1,1,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,1,1,2,1,1,1,3,1],
            [1,2,1,1,1,2,1,1,1,2,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,1,1,2,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,3,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,2,1],
            [1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,2,1],
            [1,2,1,1,1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,2,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,2,1,1,1,2,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,2,1,2,1,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,1,2,1,1,1,2,1,0,0,1,1,1,1,1,1,1,1,0,1,2,1,1,1,2,1,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,1,2,1,2,1,1,1,2,1,0,0,0,0,0,0,0,0,0,0,0,1,2,1,1,1,2,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,2,1,2,1,1,1,2,1,0,0,1,1,1,1,1,1,1,1,0,1,2,1,1,1,2,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,2,1,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,0,0,0,0,0,0,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,1,1,2,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,3,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,1,1,1,2,1],
            [1,3,1,1,1,2,1,1,1,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,1,1,2,1,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        // Inicializar o jogo
        function initGame() {
            player = { x: 1, y: 1, direction: 'right', nextDirection: 'right', visualX: 1, visualY: 1, moveProgress: 0 };
            ghosts = [];
            dots = [];
            questionItems = [];
            powerUps = [];
            walls = new Set();
            dotsCollected = 0;
            totalDots = 0;
            wallCache.clear();
            
            // Parse do labirinto
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = maze[y][x];
                    if (maze[y][x] === 1) {
                        walls.add(`${x},${y}`);
                        wallCache.set(`${x},${y}`, true);
                    } else if (cell === 2) {
                        dots.push({ x, y });
                        totalDots++;
                    } else if (cell === 3) { // 3 agora √© um item de pergunta
                        questionItems.push({ x, y, type: 'question' });
                    } else if (cell === 2 && Math.random() < 0.05) { // 5% de chance de um ponto virar power-up
                        if (Math.random() < 0.5) {
                            powerUps.push({ x, y, type: 'speed' });
                        } else {
                            powerUps.push({ x, y, type: 'freeze' });
                        }
                        // Remove o ponto normal para n√£o sobrepor
                        dots.pop();
                        totalDots--;
                    }
                }
            }
            
            // Criar fantasmas (bugs)
            ghosts = [
                { x: 18, y: 12, type: 'red', direction: 'up', lastDecision: 0, visualX: 18, visualY: 12, moveProgress: 0 },
                { x: 19, y: 12, type: 'purple', direction: 'up', lastDecision: 10, visualX: 19, visualY: 12, moveProgress: 0 },
                { x: 20, y: 12, type: 'orange', direction: 'up', lastDecision: 20, visualX: 20, visualY: 12, moveProgress: 0 },
                { x: 21, y: 12, type: 'pink', direction: 'up', lastDecision: 30, visualX: 21, visualY: 12, moveProgress: 0 }
            ];
            
            updateUI();
        }
        
        // Atualizar UI
        function updateUI() {
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            energyDisplay.textContent = energyTime > 0 ? Math.ceil(energyTime) + 's' : 'Inativa';
            dotsDisplay.textContent = dotsCollected + '/' + totalDots;
        }
        
        // Desenhar o jogo
        function draw() {
            // Limpar canvas
            ctx.fillStyle = COLORS.path;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Desenhar paredes
            ctx.fillStyle = COLORS.wall;
            walls.forEach(wallKey => {
                const [x, y] = wallKey.split(',').map(Number);
                ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });
            // Desenhar dots
            ctx.fillStyle = COLORS.dot;
            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(
                    dot.x * TILE_SIZE + TILE_SIZE / 2,
                    dot.y * TILE_SIZE + TILE_SIZE / 2,
                    3, 0, Math.PI * 2
                );
                ctx.fill();
            });
            
            // Desenhar itens de pergunta
            ctx.fillStyle = COLORS.questionItem;
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const pulse = Math.sin(Date.now() / 200) * 2;
            questionItems.forEach(item => {
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = COLORS.questionItem;
                ctx.fillText('‚ùì', item.x * TILE_SIZE + TILE_SIZE / 2, item.y * TILE_SIZE + TILE_SIZE / 2 + pulse);
                ctx.restore();
            });

            // Desenhar Power-ups
            powerUps.forEach(item => {
                let emoji = '';
                let color = '';
                if (item.type === 'speed') {
                    emoji = 'üöÄ';
                    color = 'var(--success)';
                } else if (item.type === 'freeze') {
                    emoji = '‚ùÑÔ∏è';
                    color = 'var(--info)';
                }
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.fillText(emoji, item.x * TILE_SIZE + TILE_SIZE / 2, item.y * TILE_SIZE + TILE_SIZE / 2 + pulse);
                ctx.restore();
            });
            
            // Desenhar jogador (Python)
            const playerX = player.visualX * TILE_SIZE;
            const playerY = player.visualY * TILE_SIZE;
            
            // Desenha o jogador como a cobra üêç
            ctx.font = `${TILE_SIZE * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.save();
            if (energyTime > 0) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'var(--success)';
            }
            ctx.fillText('üêç', playerX + TILE_SIZE / 2, playerY + TILE_SIZE / 2);
            ctx.restore();
            
            // Desenhar fantasmas (bugs)
            ghosts.forEach(ghost => {
                const ghostX = ghost.visualX * TILE_SIZE;
                const ghostY = ghost.visualY * TILE_SIZE;
                
                let ghostColor;
                let ghostEmoji;
                
                switch(ghost.type) {
                    case 'red':
                        ghostColor = COLORS.ghosts.red;
                        ghostEmoji = 'üêõ';
                        break;
                    case 'purple':
                        ghostColor = COLORS.ghosts.purple;
                        ghostEmoji = 'ü¶†';
                        break;
                    case 'orange':
                        ghostColor = COLORS.ghosts.orange;
                        ghostEmoji = 'üí•';
                        break;
                    case 'pink':
                        ghostColor = COLORS.ghosts.pink;
                        ghostEmoji = 'üåÄ';
                        break;
                }
                
                // Se o jogador tem energia, os fantasmas ficam azuis (vulner√°veis)
                if (energyTime > 0) {
                    ghostEmoji = 'üò®'; // Emoji assustado
                    ctx.globalAlpha = 0.7; // Fica semi-transparente
                    // Efeito de piscar quando vulner√°vel
                    if (energyTime < 3 && Math.floor(Date.now() / 200) % 2 === 0) {
                        ctx.globalAlpha = 1.0;
                    }
                }
                
                // Emoji do bug
                ctx.font = `${TILE_SIZE * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    ghostEmoji,
                    ghostX + TILE_SIZE / 2, 
                    ghostY + TILE_SIZE / 2
                );
                ctx.globalAlpha = 1.0; // Restaura a opacidade
            });
        }
        
        // Atualizar o jogo
        function update(dt) {
            if (!gameRunning || gamePaused) return;
            
            // Atualiza a posi√ß√£o visual suavemente
            movePlayer(dt);
            moveGhosts(dt);
            
            // Verificar colis√µes
            checkCollisions();
            
            // Atualizar energia
            if (energyTime > 0) {
                energyTime -= 0.016;
                if (energyTime <= 0) {
                    energyTime = 0;
                }
            }

            if (speedBoostTime > 0) {
                speedBoostTime -= dt;
                if (speedBoostTime <= 0) {
                    playerSpeed = 0.15; // Volta √† velocidade normal
                }
            }

            if (freezeTime > 0) {
                freezeTime -= dt;
            }
            
            // Verificar vit√≥ria
            if (dotsCollected >= totalDots) {
                levelUp();
            }
            
            updateUI();
        }
        
        // Mover jogador
        function movePlayer(dt) {
            // Se o jogador n√£o est√° se movendo, inicia um novo movimento
            if (player.moveProgress === 0) {
                const nextDirVec = { 'up': { x: 0, y: -1 }, 'down': { x: 0, y: 1 }, 'left': { x: -1, y: 0 }, 'right': { x: 1, y: 0 } }[player.nextDirection];
                if (!isWall(player.x + nextDirVec.x, player.y + nextDirVec.y)) {
                    player.direction = player.nextDirection;
                }

                const currentDirVec = { 'up': { x: 0, y: -1 }, 'down': { x: 0, y: 1 }, 'left': { x: -1, y: 0 }, 'right': { x: 1, y: 0 } }[player.direction];
                if (!isWall(player.x + currentDirVec.x, player.y + currentDirVec.y)) {
                    player.moveProgress = 1; // Inicia o progresso do movimento
                }
            }

            // Atualiza o progresso do movimento
            if (player.moveProgress > 0) {
                player.moveProgress -= dt / playerSpeed;

                const dirVec = { 'up': { x: 0, y: -1 }, 'down': { x: 0, y: 1 }, 'left': { x: -1, y: 0 }, 'right': { x: 1, y: 0 } }[player.direction];
                
                // Interpola a posi√ß√£o visual
                const progressRatio = 1 - player.moveProgress;
                player.visualX = player.x + dirVec.x * progressRatio;
                player.visualY = player.y + dirVec.y * progressRatio;

                if (player.moveProgress <= 0) {
                    player.moveProgress = 0;
                    player.x += dirVec.x;
                    player.y += dirVec.y;
                    player.visualX = player.x;
                    player.visualY = player.y;

                    // L√≥gica de teleporte
                    if (player.x < 0) player.x = GRID_WIDTH - 1;
                    if (player.x >= GRID_WIDTH) player.x = 0;
                    player.visualX = player.x; // Atualiza visual ap√≥s teleporte
                }
            }
        }
        
        // Mover fantasmas
        function moveGhosts(dt) {
            if (freezeTime > 0) return; // Pula o movimento se estiver congelado

            ghosts.forEach(ghost => {
                if (ghost.moveProgress === 0) {
                    const possibleMoves = getPossibleMoves(ghost);
                    if (possibleMoves.length > 1 || ghost.lastDecision > 5) { // Decide mais frequentemente
                        ghost.lastDecision = 0;
                        let targetX = player.x;
                        let targetY = player.y;

                        if (energyTime > 0) { // Foge
                            targetX = Math.random() > 0.5 ? 1 : GRID_WIDTH - 2;
                            targetY = Math.random() > 0.5 ? 1 : GRID_HEIGHT - 2;
                        } else { // Persegue
                            const playerDirVec = { 'up': { x: 0, y: -1 }, 'down': { x: 0, y: 1 }, 'left': { x: -1, y: 0 }, 'right': { x: 1, y: 0 } }[player.direction];
                            if (ghost.type === 'pink') {
                                targetX += playerDirVec.x * 4;
                                targetY += playerDirVec.y * 4;
                            }
                        }

                        let bestDir = ghost.direction;
                        let minDistance = Infinity;
                        for (const move of possibleMoves) {
                            const distance = Math.hypot(targetX - (ghost.x + move.vec.x), targetY - (ghost.y + move.vec.y));
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestDir = move.dir;
                            }
                        }
                        ghost.direction = bestDir;
                    }
                    ghost.lastDecision++;

                    const dirVec = { 'up': { x: 0, y: -1 }, 'down': { x: 0, y: 1 }, 'left': { x: -1, y: 0 }, 'right': { x: 1, y: 0 } }[ghost.direction];
                    if (!isWall(ghost.x + dirVec.x, ghost.y + dirVec.y)) {
                        ghost.moveProgress = 1;
                    }
                }

                if (ghost.moveProgress > 0) {
                    ghost.moveProgress -= dt / ghostSpeed;
                    const dirVec = { 'up': { x: 0, y: -1 }, 'down': { x: 0, y: 1 }, 'left': { x: -1, y: 0 }, 'right': { x: 1, y: 0 } }[ghost.direction];
                    const progressRatio = 1 - ghost.moveProgress;
                    ghost.visualX = ghost.x + dirVec.x * progressRatio;
                    ghost.visualY = ghost.y + dirVec.y * progressRatio;

                    if (ghost.moveProgress <= 0) {
                        ghost.moveProgress = 0;
                        ghost.x += dirVec.x;
                        ghost.y += dirVec.y;
                        ghost.visualX = ghost.x;
                        ghost.visualY = ghost.y;
                    }
                }
            });
        }

        function getPossibleMoves(character) {
            const moves = [];
            const directions = {
                'up': { x: 0, y: -1 }, 'down': { x: 0, y: 1 },
                'left': { x: -1, y: 0 }, 'right': { x: 1, y: 0 }
            };
            const opposite = {
                'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left'
            };

            for (const dir in directions) {
                // Impede o bug de fazer uma curva de 180 graus
                if (dir === opposite[character.direction]) {
                    continue;
                }

                const vec = directions[dir];
                if (!isWall(character.x + vec.x, character.y + vec.y)) {
                    moves.push({ dir, vec });
                }
            }
            return moves;
        }
        
        // Verificar colis√µes
        function checkCollisions() {
            for (let i = dots.length - 1; i >= 0; i--) {
                if (dots[i].x === player.x && dots[i].y === player.y) {
                    dots.splice(i, 1);
                    dotsCollected++;
                    score += 10;
                }
            }
            
            for (let i = questionItems.length - 1; i >= 0; i--) {
                if (questionItems[i].x === player.x && questionItems[i].y === player.y) {
                    questionItems.splice(i, 1);
                    showQuestion();
                }
            }

            for (let i = powerUps.length - 1; i >= 0; i--) {
                if (powerUps[i].x === player.x && powerUps[i].y === player.y) {
                    const powerUp = powerUps.splice(i, 1)[0];
                    if (powerUp.type === 'speed') {
                        playerSpeed = 0.08; // Mais r√°pido
                        speedBoostTime = 5; // por 5 segundos
                    } else if (powerUp.type === 'freeze') {
                        freezeTime = 4; // por 4 segundos
                    }
                }
            }
            
            ghosts.forEach(ghost => {
                if (ghost.x === player.x && ghost.y === player.y) {
                    if (energyTime > 0) {
                        ghost.x = 19; ghost.y = 12; // Manda de volta para o esconderijo
                        ghost.visualX = 19; ghost.visualY = 12;
                        score += 200;
                    } else {
                        lives--;
                        if (lives <= 0) {
                            gameRunning = false;
                            showGameOver();
                        } else {
                            player.x = 1;
                            player.y = 1; 
                            player.visualX = 1; player.visualY = 1;
                        }
                    }
                }
            });
        }
        
        // Verificar se √© parede
        function isWall(x, y) {
            const key = `${x},${y}`;
            if (wallCache.has(key)) {
                return true;
            }
            return false;
        }
        
        // Subir de n√≠vel
        function levelUp() {
            level++;
            score += 1000;
            initGame();
        }
        
        // Mostrar game over
        function showGameOver() {
            finalScoreDisplay.textContent = score;
            finalLevelDisplay.textContent = level;
            gameOverModal.style.display = 'flex';
        }

        // --- NOVA L√ìGICA DE PERGUNTAS ---
        function showQuestion() {
            gamePaused = true;
            currentQuestion = pythonQuestions[Math.floor(Math.random() * pythonQuestions.length)];
            questionText.textContent = currentQuestion.question;
            answersContainer.innerHTML = '';

            currentQuestion.answers.forEach((answer, index) => {
                const button = document.createElement('button');
                button.className = 'answer-btn';
                button.textContent = answer;
                button.onclick = () => checkAnswer(index);
                answersContainer.appendChild(button);
            });

            let timeLeft = QUESTION_TIME;
            questionTimeLeftDisplay.textContent = timeLeft;
            questionModal.style.display = 'flex';

            questionTimer = setInterval(() => {
                timeLeft--;
                questionTimeLeftDisplay.textContent = timeLeft;
                if (timeLeft <= 0) {
                    checkAnswer(-1); // -1 indica que o tempo esgotou
                }
            }, 1000);
        }

        function checkAnswer(selectedIndex) {
            clearInterval(questionTimer);
            const isCorrect = selectedIndex === currentQuestion.correct;
            const buttons = answersContainer.querySelectorAll('.answer-btn');

            buttons.forEach((btn, index) => {
                btn.disabled = true;
                if (index === currentQuestion.correct) {
                    btn.style.background = 'var(--success)';
                } else if (index === selectedIndex) {
                    btn.style.background = 'var(--danger)';
                }
            });

            if (isCorrect) {
                energyTime = ENERGY_DURATION;
                score += 100;
            } else {
                // Pode adicionar uma penalidade aqui, se desejar
            }

            setTimeout(() => {
                questionModal.style.display = 'none';
                gamePaused = false;
            }, 1500);
        }
        
        // Loop do jogo
        let lastTime = 0;
        function gameLoop(timestamp) {
            const dt = (timestamp - (lastTime || timestamp)) / 1000; // Garante que o primeiro dt seja 0
            lastTime = timestamp;
            update(dt || 0); // Passa o delta time para o update
            draw();
            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Event listeners
        startBtn.addEventListener('click', () => {
            if (!gameRunning) {
                // Ajusta o tamanho do canvas dinamicamente
                canvas.width = GRID_WIDTH * TILE_SIZE;
                canvas.height = GRID_HEIGHT * TILE_SIZE;

                gameRunning = true;
                gamePaused = false;
                initGame();
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        });
        
        pauseBtn.addEventListener('click', () => {
            if (gameRunning) {
                gamePaused = !gamePaused;
                pauseBtn.textContent = gamePaused ? '‚ñ∂Ô∏è Continuar' : '‚è∏Ô∏è Pausar';
            }
        });
        
        resetBtn.addEventListener('click', () => {
            // Ajusta o tamanho do canvas dinamicamente
            canvas.width = GRID_WIDTH * TILE_SIZE;
            canvas.height = GRID_HEIGHT * TILE_SIZE;

            score = 0;
            lives = 3;
            level = 1;
            gameRunning = false;
            gamePaused = false;
            gameOverModal.style.display = 'none';
            draw();
        });
        
        restartBtn.addEventListener('click', () => {
            // Ajusta o tamanho do canvas dinamicamente
            canvas.width = GRID_WIDTH * TILE_SIZE;
            canvas.height = GRID_HEIGHT * TILE_SIZE;

            score = 0;
            lives = 3;
            level = 1;
            gameRunning = true;
            gamePaused = false;
            gameOverModal.style.display = 'none';
            // initGame() √© chamado dentro do startBtn.click, n√£o precisa aqui
            startBtn.click();
        });
        
        // Controles do teclado
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gamePaused) return;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                    player.nextDirection = 'up';
                    break;
                case 'ArrowDown':
                case 's':
                    player.nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                case 'a':
                    player.nextDirection = 'left';
                    break;
                case 'ArrowRight':
                case 'd':
                    player.nextDirection = 'right';
                    break;
            }
        });
        
        // Inicializar
        // Ajusta o tamanho do canvas dinamicamente na carga inicial
        canvas.width = GRID_WIDTH * TILE_SIZE;
        canvas.height = GRID_HEIGHT * TILE_SIZE;

        initGame();
        draw();
    </script>
</body>
</html>